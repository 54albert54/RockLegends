'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class TouchHandler$1 {
    constructor(options) {
        let defaults = {
            'element': document.body,
            'start': (ev) => {},
            'move': (ev) => {},
            'end': (ev) => {},
            'width': 100,
            'height': 100,
            'left': 0,
            'top':0,
            'sticks':[]
        };
        this.currentTouches = [];
        this.options = Object.assign({}, defaults, options);

        this.startFn = (ev) => this.start(ev);
        this.moveFn = (ev) => this.move(ev);
        this.endFn = (ev) => this.end(ev);

        this.bindEvents();
    }

    addStick(stick) {
        this.options.sticks.push(stick);
    }

    removeStick(stick) {
        let index = this.options.sticks.indexOf(stick);
        if(index >= -1) {
            this.options.sticks.splice(index, 1);
        }
    }

    bindEvents() {
        let el = this.options['element'];
        el.addEventListener('touchstart', this.startFn, {passive: false});
        el.addEventListener('touchmove', this.moveFn, {passive: false});
        el.addEventListener('touchend', this.endFn, {passive: false});
        el.addEventListener('touchcancel', this.endFn, {passive: false});
    }

    unbindEvents() {
        let el = this.options['element'];
        el.removeEventListener('touchstart', this.startFn);
        el.removeEventListener('touchmove', this.moveFn);
        el.removeEventListener('touchend', this.endFn);
        el.removeEventListener('touchcancel', this.endFn);
    }

    inRange(x, y, stick) {
        let containerBounds = this.options.element.getBoundingClientRect();
        let width = containerBounds.width * (stick.options.width / 100);
        let height = containerBounds.height * (stick.options.height / 100);
        let xMin = containerBounds.width * (stick.options.left / 100);
        let yMin = containerBounds.width * (stick.options.top / 100);
        
        if( x < xMin || x > xMin + width) return false;
        if( y < yMin || y > yMin + height) return false;
        return true;
    }

    findStick(x, y) {
        let result = false;
        this.options.sticks.forEach(stick => {
            if(this.inRange(x, y, stick)) {
                result = stick;
            }
        });

        return result;
    }

    start(event) {
        for(let index = 0; index < event.targetTouches.length; index++) {
            let touch = event.targetTouches[index];
            if(this.addTouchToStick(touch)) {
                event.preventDefault();
                return false;
            }
        }

    }

    hasCurrentTouch(stick) {
        for(let index = 0; index < this.currentTouches.length; index++) {
            let currentTouch = this.currentTouches[index];
            if(currentTouch.stick == stick) {
                return true;
            }
        }
        return false;
    }

    addTouchToStick(touch) {
        let stick = this.findStick(touch.pageX, touch.pageY);
        if(this.hasCurrentTouch(stick)) return false;
        if(stick && !this.findTouch(this.currentTouches, touch.identifier)){
            this.currentTouches.push({
                identifier: touch.identifier,
                stick: stick,
                x:touch.pageX,
                y:touch.pageY
            });
            stick.start(touch);
            return true;
        }
        return false;
    }

    findTouch(touches, touchIdentifier) {
        for(let index = 0; index < touches.length; index++) {
            if(touches[index].identifier == touchIdentifier) {
                return touches[index];
            }
        }
        return false;
    }

    endOldTouches(touches) {
        for(let i = 0; i  < this.currentTouches.length; i++) {
            if(!this.findTouch(touches, this.currentTouches[i].identifier)) {
                this.currentTouches[i].stick.end();
                this.currentTouches.splice(i,1);
            }
        }
    }

    move(event) {
        if(!this.currentTouches.length) return;
        for(let i = 0; i  < event.changedTouches.length; i++) {
            let changedTouch = event.changedTouches[i];
            let existingTouch = this.findTouch(this.currentTouches, changedTouch.identifier);
            if(existingTouch) {
                let changeX = changedTouch.pageX - existingTouch.x;
                let changeY = changedTouch.pageY - existingTouch.y;
                
                existingTouch.stick.move(changeX, changeY);
                existingTouch.x = changedTouch.pageX;
                existingTouch.y = changedTouch.pageY;

                event.preventDefault();
                return false;
            }
        }

    }

    end(event) {
        if(!this.currentTouches.length) return;
        this.endOldTouches(event.targetTouches);
        event.preventDefault();

        return false; 
    }
}

class TouchContainer {
    constructor(options) {
        let defaults = {
            'container': document.body,
            'width': 50,
            'height': 50,
            'left': 0,
            'top':50
        };
        this.options = Object.assign({}, defaults, options);
        this.createElement();
    }
    createElement() {
        this.el = document.createElement('div');
        var rect = this.options.container.getBoundingClientRect();
        this.el.style.position='absolute';
        this.el.style.width = this.options.width + 'vw';
        this.el.style.height = this.options.height + 'vh';
        this.el.style.left = this.options.left + 'vw';
        this.el.style.top = this.options.top + 'vh';
        this.el.style.background= "#999999AA";
        
    }

    show() {
        this.options.container.appendChild(this.el);
    }
    hide() {
        this.options.container.removeChild(this.el);
    }
}

class Stick {
    /**
     * Creates an instance of VirtualJoyStick.
     * @param {any} options 
     * @memberof VirtualJoyStick
     */
    constructor(options) {
        let defaults = {
            'button-color': '#FF0000',
            'track-color': '#00FF0099',
            'button-size': 12.5,
            'button-stroke-size':0,
            'track-size': 15,
            'track-stroke-size':2,
            'track-stroke-color':'#FFFFFF',
            'track-stroke-size':2,
            'tracking-element': document.body,
        };
        this.options = Object.assign({}, defaults, options);
        this._isAttached = false;
        this.x = 0;
        this.y = 0;

        this.createCanvas();
    }
    /**
     * Creates the canvas
     * 
     * @memberof VirtualJoyStick
     */
    createCanvas() {
        this.ratio = window.devicePixelRatio;
        this.canvas = document.createElement('canvas');
        const dp1 = this.options['track-size'] + (this.options['track-stroke-size'] * 2);
        this.canvas.width = dp1 * this.ratio;
        this.canvas.height = dp1 * this.ratio;
        this.canvas.style.width = dp1 + 'px';
        this.canvas.style.height = dp1 + 'px';
        this.context = this.canvas.getContext('2d');
    }

    start(event) {
        if(!this._isAttached) return;

        this.x = 0;
        this.y = 0;
        this.px = 0;
        this.py = 0;
    }

    getAngle(x, y) {
        if(x == 0) {
            return 0;
        }
        return Math.atan(y/x);
    }

    getMultiplier(x) {
        return x < 0 ? -1 : 1;
    }

    getAxisDelta(x) {
        let multiplier = this.getMultiplier(x);
        return x * multiplier > 0.5 ? 1 * multiplier : 0
    }

    getAxis() {
        return {
            x: this.x,
            y: this.y,
            dx: this.getAxisDelta(this.x),
            dy: this.getAxisDelta(this.y)
        }
    }

    move(changeX, changeY) {
        
        if(!this._isAttached) return;
        this.px = this.px + changeX;
        this.py = this.py + changeY;

        let mag = Math.sqrt((this.px * this.px) + (this.py * this.py));

        let rads = this.getAngle(this.px, this.py);
        let maxX = Math.abs(Math.cos(rads));
        let maxY = Math.abs(Math.sin(rads));

        if(maxX == 1) {
            maxY = 1;
        }
        let trackRange = (this.options['track-size'] / (2 * this.ratio));
        let fx = Math.min(maxX, this.px / trackRange);
        let fy = Math.min(maxY, this.py / trackRange);
        this.x = Math.max(-maxX, fx);
        this.y = Math.max(-maxY, fy);
    }

    end(event) {
        this.x = 0;
        this.y = 0;
    }

    /**
     * Hides the joystick
     * 
     * @memberof VirtualJoyStick
     */
    hide() {
        this._isAttached = false;
        this.canvas.parentNode.removeChild(this.canvas);
    }

    /**
     * Shows the joystick
     * 
     * @memberof VirtualJoyStick
     */
    show() {
        this._isAttached = true;
        this.options['tracking-element'].appendChild(this.canvas);
    }

    setPosition(x, y) {
        this.canvas.style.position = 'absolute';
        let trackSize = (this.options['track-size'] / (2 * this.ratio));

        this.canvas.style.left = x - trackSize + 'px';
        this.canvas.style.top = y - trackSize + 'px';
    }
    /**
     * Renders a frame
     * 
     * @returns 
     * @memberof VirtualJoyStick
     */
    draw() {
        if(!this._isAttached) return;
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        const trackSize = this.options['track-size'] / 2;
        this.drawCircle(
            trackSize + this.options['track-stroke-size'],
            trackSize + this.options['track-stroke-size'],
            trackSize,
            this.options['track-color'],
            this.options['track-stroke-size'] * this.ratio,
            this.options['track-stroke-color']
        );

        let trackRange = (this.options['track-size'] - this.options['button-size']) / 2;

        this.drawCircle(
            trackSize + (this.x * trackRange) + this.options['track-stroke-size'],
            trackSize + (this.y * trackRange) + this.options['track-stroke-size'],
            (this.options['button-size'] / 2),
            this.options['button-color'],
            this.options['button-stroke-size'] * this.ratio,
            this.options['button-stroke-color']
        );
    }
    /**
     * Draws a circle
     * 
     * @param {any} x 
     * @param {any} y 
     * @param {any} radius 
     * @param {any} fillColor 
     * @memberof VirtualJoyStick
     */
    drawCircle(x, y, radius, fillColor, strokeSize,strokeColor) {
        this.context.beginPath();
        this.context.arc(x,y,radius, 0, 2 * Math.PI, false);
        this.context.fillStyle = fillColor;
        this.context.lineWidth = strokeSize;
        this.context.strokeStyle = strokeColor;
        this.context.fill();
        this.context.stroke();
    }
}

const TouchHandler = TouchHandler$1;

class VirtualStick {
    constructor(options) {
        const defaults = {
            'container': document.body,
            'left': 0,
            'top': 0,
            'width': 100,
            'height': 100,
            'track-size': 180,
            'button-size': 100,
            'button-color': '#FFFFFF99',
            'button-stroke-color': '#FFFFFF',
            'button-stroke-size': 2,
            'track-color': '#00000099',
            'track-stroke-color': '#FFFFFF',
            'track-stroke-size': 2,
            'touch-handler': null
        };

        this.options = Object.assign({}, defaults, options);

        if (!this.options['touch-handler']) {
            this.options['touch-handler'] = new TouchHandler({ 'element': this.options.container });
        }

        this.container = new TouchContainer();
        this.stick = new Stick({
            'tracking-element': this.options.container,
            'button-size': this.options['button-size'],
            'button-color': this.options['button-color'],
            'track-color': this.options['track-color'],
            'track-size': this.options['track-size'],
            'track-stroke-color': this.options['track-stroke-color'],
            'track-stroke-size': this.options['track-stroke-size']
        });

        this.options['touch-handler'].addStick(this);
    }

    start(touch) {
        this.stick.setPosition(touch.pageX, touch.pageY);
        this.stick.show();
        this.stick.start();
    }
    move(x, y) {
        this.stick.move(x, y);
    }
    end() {
        this.stick.hide();
        this.stick.end();
    }

    draw() {
        this.stick.draw();
    }

    unbind() {
        this.options['touch-handler'].removeStick(this);
    }

    getAxis() {
        return this.stick.getAxis();
    }
}

exports.TouchHandler = TouchHandler;
exports.VirtualStick = VirtualStick;
exports['default'] = VirtualStick;
